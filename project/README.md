#### Не забравяйте да сложите `dist-newstyle` в `.gitignore`-а си!

## Предварителни стъпки

Би трябвало вече да имате `cabal-install` (можете да верифицирате това като пуснете `cabal --version` успешно) от инструкциите в `README`-то.
Ако го нямате, следвайте инструкциите за инсталация на `ghcup` от главното `README`, след което
```
ghcup install cabal-install
```
би трябвало да подсигури че го имате.

Допълнително, трябва да пуснете
```
cabal update
```

## Инструкции за слагане на готов еднофайлов проект в шаблона

0. Взимате си сорс кода, слагате го в `src/Lib.hs`, внимавайки да не затриете
    ```haskell
    module Lib where
    ```
    от най-горе.
1. Ако имате някакво `IO ()`, което е "входна" точка на програмата ви,
    правите тя да се казва `main` (т.е. сменяте тялото на наличния в `app/Main.hs`
    ```haskell
    main :: IO ()
    main = putStrLn "Hi!"
    ```
    да е каквото ви трябва на вас.)
2. Слагате каквито външни пакети ползвате под секцията `dependencies` в
    `package.yaml` файла. Например в момента там седят пакетите:
    * [`base`](https://hackage.haskell.org/package/base)
    (ограничен до версии по-нови или равни на 4.7 по-стари от 5 - не е важно)

    Да речем, че на вас ви трябва [`Data.Map.Lazy`](https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Lazy.html) от [`containers`](https://hackage.haskell.org/package/containers-0.6.2.1).

    Слагате на нов ред
    ```yaml
    - containers
    ```
    и сте готови.

    Секцията `dependencies` вече изглежда така:
    ```yaml
    dependencies:
    - base >= 4.7 && < 5
    - containers
    ```

### Инструкции за работа с повече от един source файл

Ако вашият проект се състои от повече от един файл, ще трябва да ги изброите всичките в `project.cabal`
Това включва и случаите в които искате да добавите нов файл - това се случва отново чрез добавяне в `project.cabal`.

В момента `project.cabal` изглежда така:
```cabal
library
  exposed-modules:
      Lib
  other-modules:
      Paths_project
```

Ако искаме да добавим друг модул с име `Foo.Bar.Baz`, трябва да се подсигурим няколко неща:
1. Трябва модулът да се казва `Foo.Bar.Baz`, т.е. най-горе във файла пише `module Foo.Bar.Baz ......... where`
2. Трябва файлът на модула да се намира в `src/Foo/Bar/Baz.hs`
3. Трябва да добавим модула в `expoed-modules` ако искаме да може да се достъпва от извън `src` (например в `Main.hs` или в тестове), или в `other-modules`, ако сме окей да се достъпва само от неща в `src`

    Това е опростена версия на реалното изискване но би трябвало да ви свърши работа.

В крайна сметка проектът ни би изглеждал така:

#### Файлова структура
```
> tree src
src
├── Foo
│   └── Bar
│       └── Baz.hs
└── Lib.hs

3 directories, 2 files
```

#### Минимално съдържание на `src/Foo/Bar/Baz.hs`

```
> cat src/Foo/Bar/Baz.hs
module Foo.Bar.Baz where
```

#### Крайн версия на `project.cabal`
```
  exposed-modules:
      Lib
      Foo.Bar.Baz
  other-modules:
      Paths_project
```

## Пускане на проекта ви
**N.B. Първото пускане ще отнеме сравнително голямо количество време,
тъй като `stack` тегли специфична версия на `ghc` и комплира специфични пакети за нея, които са проверени че работят заедно**

Извиквания на `stack`:
* `cabal build` - компилира source файловете ви
* `cabal repl` - пуска `ghci` в което са заредени source файловете ви
* `cabal run` - изпълнява `main` действието


## Структура
В `src` можете да слагате всичките си файлове от проекта.

Отбелязвам, че ако искате да имате модул `Universe.Atom`, той трябва да седи
**в директория** `Universe`, с име `Atom.hs`, т.е. `src/Universe/Atom.hs`

В `project.cabal` седят разни опции на компилатора, например предупреждения.

По време на разработка може да е полезно да се закоментира `-Werror` временно,
за да може да се отложи оправянето им.

При ползата на допълнителни пакети те се слагат под секцията `dependencies`.

## Препоръчителна чистота на кода

Можете (и препоръчвам) да си инсталирате `hlint`:

`cabal install hlint`

След това можете да пуснете `hlint` върху вашите файлове,
за да ви препоръча начини да подобрите кода си.

Това е полезно за вас защото

* се учите да пишете по-"идиоматичен" Haskell
* не трябва да ме чакате за feedback за сравнително голяма част от коментарите, които бих сложил
